# 2章

## strace
* プログラムをこのコマンドを使って開始すると、そのプログラムが呼ぶシステムコールの一覧を吐き出す
* 使用例
```bash
strace -o hello.log ./hello.out
```

## sar
* リソースの情報を得る。
* 使用例
```bash
sar -P ALL 1 # CPU使用率を1秒ごとに取得。%user行と%nice行はユーザモードでのプロセス実行時間割合。%system行はカーネルモードでの(省略)
sar -r # メモリ使用率
sar -q # runq-sz列は、実行中プロセスと実行待ちプロセスの数
```

## kill
* 指定したPIDのプロセスを終了させる
* PIDは、`./loop &`のように`&`を付けて実行した際に表示されたり、`top`コマンドによって確認できる

## ldd
* （コンパイルされた）プログラムを指定すると、そのプログラムがどのようなライブラリをリンクしているかを取得
* 使用例
```bash
ldd /bin/echo
```

# 3章

## fork()
* プロセスのコピーを生成する
* 同じプログラムの処理を複数のプロセスに分けて処理する場合に使う
* 生成元を親プロセス、生成されたプロセスを子プロセスと呼ぶ
* 親プロセスのメモリが子プロセスにコピーされる

## execve()
* まったく別のプログラムを生成する
* 呼び出し元のプロセスのメモリは、新プロセスのメモリに上書きされる
* つまり、fork()と違って、exec()を発行したら呼び出し元には処理が戻らない

## readelf
* Linuxの実行ファイルは、Executable and Linkable Format(ELF)というフォーマット
* ELFの各種情報を取得するコマンドが`readelf`

# 4章

## taskset
* 指定のプログラムを`-c`オプションによって指定した論理CPU上でのみ動作させる
* 使用例
```bash
taskset -c 0 ./a.out # 論理CPU0番でのみ実行
```

## コンテキストスイッチ
* 論理CPU上で動作するプロセスが切り替わること
* タイムスライスのタイミングが来たら発生する
* 複数のプロセスが実行されていても、ある瞬間に論理CPU上で動作できるプロセスは1つだけ

## ps ax
* システムに存在するプロセスを一覧表示する
* 使用例
```bash
ps ax | wc -l # 総プロセス数を表示
```
* `STAT`フィールド
|1文字目|状態|
|:--|:--|
|R|実行状態 or 実行待ち状態|
|S or D|スリープ状態|
|Z|ゾンビ状態|

## プロセスの状態
|状態|意味|
|:--|:--|
|実行状態|現在論理CPUを使っている|
|実行待ち状態|CPU時間割当てを待機している|
|スリープ状態|イベント発生を待機。それまではCPU時間を使わない|
|ゾンビ状態|プロセス終了後に親プロセスが終了状態を受け取るのを待機している|

* 全プロセスがスリープ状態のとき、CPUはidle状態となる

## スループット
* 単位時間あたりの総仕事量
* 完了したプロセス数 / 経過時間
* CPUのidle時間の割合が低いほど高まる

## レイテンシ
* 処理の開始から終了までの経過時間
* 処理終了時間 - 処理開始時間
* プロセスが増えるほど悪化する

## ロードバランサ
* 複数の論理CPU間でプロセスを公平に分配する
    * 各CPUは割り当てられた各プロセスに平等にCPU時間を割り当てる(ラウンドロビンスケジューリング)

## 論理CPUの数
* `/proc/cpuinfo`のテキスト中の`processor`の数
* `grep -c processor /proc/cpuinfo`で確認可能
* マルチコアCPU環境では、複数プロセスを同時に動かさないとスループットは上がらない
* プロセス数を論理CPU数より多くしてもスループットは上がらない

## time
* real
    * 所要時間(プログラムの開始から終了までの時間)
* user
    * 各プロセスが実際に論理CPUをユーザモードで使用した時間の合計
    * スループットが高ければ、realより多くなる場合がある
* sys
    * 各プロセスが実際に論理CPUをカーネルモードで使用した時間の合計

## nice()
* プロセスの実行優先度を`-19 ~ 20`までの間で設定する
* 優先度の高いプロセスほど、通常よりCPU時間を多く得られる