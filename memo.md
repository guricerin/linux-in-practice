# 2章

## strace
* プログラムをこのコマンドを使って開始すると、そのプログラムが呼ぶシステムコールの一覧を吐き出す
* 使用例
```bash
strace -o hello.log ./hello.out
```

## sar
* リソースの情報を得る。
* 使用例
```bash
sar -P ALL 1 # CPU使用率を1秒ごとに取得。%user行と%nice行はユーザモードでのプロセス実行時間割合。%system行はカーネルモードでの(省略)
sar -r # メモリ使用率
sar -q # runq-sz列は、実行中プロセスと実行待ちプロセスの数
```

## kill
* 指定したPIDのプロセスを終了させる
* PIDは、`./loop &`のように`&`を付けて実行した際に表示されたり、`top`コマンドによって確認できる

## ldd
* （コンパイルされた）プログラムを指定すると、そのプログラムがどのようなライブラリをリンクしているかを取得
* 使用例
```bash
ldd /bin/echo
```

# 3章

## fork()
* プロセスのコピーを生成する
* 同じプログラムの処理を複数のプロセスに分けて処理する場合に使う
* 生成元を親プロセス、生成されたプロセスを子プロセスと呼ぶ
* 親プロセスのメモリが子プロセスにコピーされる

## execve()
* まったく別のプログラムを生成する
* 呼び出し元のプロセスのメモリは、新プロセスのメモリに上書きされる
* つまり、fork()と違って、exec()を発行したら呼び出し元には処理が戻らない

## readelf
* Linuxの実行ファイルは、Executable and Linkable Format(ELF)というフォーマット
* ELFの各種情報を取得するコマンドが`readelf`

# 4章

## taskset
* 指定のプログラムを`-c`オプションによって指定した論理CPU上でのみ動作させる
* 使用例
```bash
taskset -c 0 ./a.out # 論理CPU0番でのみ実行
```

## コンテキストスイッチ
* 論理CPU上で動作するプロセスが切り替わること
* タイムスライスのタイミングが来たら発生する
* 複数のプロセスが実行されていても、ある瞬間に論理CPU上で動作できるプロセスは1つだけ

## ps ax
* システムに存在するプロセスを一覧表示する
* 使用例
```bash
ps ax | wc -l # 総プロセス数を表示
```
* `STAT`フィールド 

|1文字目|状態|
|:--|:--|
|R|実行状態 or 実行待ち状態|
|S or D|スリープ状態|
|Z|ゾンビ状態|

## プロセスの状態
|状態|意味|
|:--|:--|
|実行状態|現在論理CPUを使っている|
|実行待ち状態|CPU時間割当てを待機している|
|スリープ状態|イベント発生を待機。それまではCPU時間を使わない|
|ゾンビ状態|プロセス終了後に親プロセスが終了状態を受け取るのを待機している|

* 全プロセスがスリープ状態のとき、CPUはidle状態となる

## スループット
* 単位時間あたりの総仕事量
* 完了したプロセス数 / 経過時間
* CPUのidle時間の割合が低いほど高まる

## レイテンシ
* 処理の開始から終了までの経過時間
* 処理終了時間 - 処理開始時間
* プロセスが増えるほど悪化する

## ロードバランサ
* 複数の論理CPU間でプロセスを公平に分配する
    * 各CPUは割り当てられた各プロセスに平等にCPU時間を割り当てる(ラウンドロビンスケジューリング)

## 論理CPUの数
* `/proc/cpuinfo`のテキスト中の`processor`の数
* `grep -c processor /proc/cpuinfo`で確認可能
* マルチコアCPU環境では、複数プロセスを同時に動かさないとスループットは上がらない
* プロセス数を論理CPU数より多くしてもスループットは上がらない

## time
* real
    * 所要時間(プログラムの開始から終了までの時間)
* user
    * 各プロセスが実際に論理CPUをユーザモードで使用した時間の合計
    * スループットが高ければ、realより多くなる場合がある
* sys
    * 各プロセスが実際に論理CPUをカーネルモードで使用した時間の合計

## nice()
* プロセスの実行優先度を`-19 ~ 20`までの間で設定する
* 優先度の高いプロセスほど、通常よりCPU時間を多く得られる

# 5章

## free 
* システムが搭載するメモリ量と使用中のメモリ量を表示する
* 数値の単位はすべてKB 

|フィールド|意味|
|:--|:--|
|total|システムに搭載されている全メモリ量|
|free|見かけ上の空きメモリ|
|buf/cache|freeの値が減少してきたらカーネルによって解放される|
|available|実質的な空きメモリ。free + 予備のカーネル内メモリ|

## Out Of Memory
* メモリ不足状態
* OOM killer
    * メモリ管理システムが適当なプロセスを強制終了し、OOMを解消するヤバい機能

## メモリ割り当て(仮想記憶なし)
* プロセス生成時
* プロセス生成後、追加で動的メモリ割り当て時

## 動的メモリ割り当ての問題
* メモリの断片化
* 別用途のメモリへの不正アクセス
* マルチプロセスの扱いが困難

## 仮想記憶
* プロセスから物理アドレス(実際のメモリ)にアクセスさせる場合、仮想アドレスを経由して間接的にアクセスさせる
* 直接アクセスする方法はない
* 動的メモリ割り当ての問題を解消

## ページテーブル
* 仮想アドレスと物理アドレスの対応表
* アドレスの変換はページ単位で行われる
* ページテーブルエントリ
    * 1つのページに対応するデータ
    * 仮想アドレスに紐付いている物理アドレスがここに格納されている
* ページのサイズはCPUアーキテクチャごとに決まっている
* ページフォールト 
    * 物理アドレスと紐付いていない仮想アドレスにプロセスがアクセスすると、CPU上で発生する割込み
    * カーネル内のページフォールトハンドラが駆動し、SIGSEGVシグナルをプロセスに通知
    * メジャーフォールト
        * ストレージへのアクセスが発生するページフォールト ex. スワッピング
        * 影響大
    * マイナーフォールト
        * メジャーフォールト以外

## プロセス生成時のメモリ割り当て
* プログラムの実行ファイルを読み出し、コード領域とデータ領域を物理メモリに割り当て、コピーする
* プロセスのページテーブルを作成、仮想アドレス空間と物理アドレス空間をマッピング
* エントリポイントのアドレスから実行開始

## プロセスへのメモリ追加割り当て
* プロセスが新規にメモリを要求
* カーネルは新規にメモリを割り当て、対応するページテーブルを作成(プロセスのページテーブルを拡張)
* 割り当てたメモリの物理アドレスに対応する仮想アドレスをプロセスに返す

## メモリ割り当て関数
* mmap()
    * ページ単位でメモリを獲得
* malloc()
    * バイト単位でメモリを獲得
    * Linuxでは、内部でmmap()をコールしている
    + glibcは事前にmmap()をコールして大きなメモリ領域をプールしておく
    * プログラムからmalloc()がコールされたら、その領域から要求量をバイト単位で切り出す
    * 予備のメモリが不足すれば再度mmap()をコールする
* メモリ量報告
    * 自分が使用しているメモリ量を報告するプログラムの値と、Linuxから見たプロセスの使用メモリ量は、だいたい異なる
        * たいてい後者のほうが大きい

## ファイルマップ
* mmap()をコールして、ストレージ上にあるファイルの内容をメモリに読み出し(コピーし)、その領域を仮想アドレス空間にマップする
* アクセスした領域は所定のタイミングでストレージ上のファイルに書き戻される

## デマンドページング
* 実は各ページには3つの状態がある
    1. プロセスには未割り当て
    2. プロセスと物理メモリの両方が割り当て済み 
    3. プロセスには割り当て済みだが、物理メモリは未割り当て
* プロセス生成時には、上記の3の状態になる
* プロセスが獲得したメモリ領域にアクセスしてはじめて、物理メモリが割り当てられ2の状態に遷移する
    * このとき、CPUにおいてページフォールトが発生
    * カーネルのページフォールトハンドラーが1か3の状態を検知し、3であればSIGSGVを通知することなく物理メモリを割り当て、ページテーブルを書き換える(2の状態)
    * ユーザモードに戻り、プロセスは実行を継続する
* これにより、メモリ領域を事前にプールしていても実際の物理メモリが無駄にならずに済む

## 2種類のメモリ枯渇
* 仮想メモリの枯渇
    * 物理メモリがいくら余っていようが発生する
    * 仮想アドレス空間が4GB程度のx86アーキテクチャでは頻繁
    * 仮想アドレス空間が128TBもあるx86_64アーキテクチャでは稀
* 物理メモリの枯渇
    * 仮想メモリがいくら余っていようが発生する

## コピーオンライト
* 例えばfork()は親プロセスのメモリを子プロセスに丸ごとコピーするのではなく、ページテーブルだけコピーする
* ページをだけなら物理メモリを共有している
* 親か子のどちらかがページを更新しようとしたらページフォールトが発生
* カーネルのページフォールトハンドラが駆動し、それまでの(物理メモリ上の)共有メモリを親子共有メモリ、親専用メモリに分割し、親専用メモリをコピーして子専用メモリを作成
* その後のそれぞれの専用メモリは読み書き自由となる

## スワップ
* Out Of Memory に対する救済措置
* スワッピング
    * ページングとも
    * 以下の2つ
* スワップアウト
    * ページアウトとも
    * 物理メモリ枯渇時に物理メモリを獲得した際(ページフォールト)、既存の使用中物理メモリの一部をストレージデバイス上に一時的に退避させる
    * 退避先をスワップ領域と呼ぶ
    * Windowsではスワップ領域のことをなぜか仮想メモリと呼ぶ
* スワップイン
    * ページインとも
    * 物理メモリに空きができ、スワップ領域に退避させていたデータにアクセスするプロセスがあれば、そのデータを物理メモリに戻す
* スラッシング
    * 物理メモリが常に足りず、メモリアクセスのたびにスワッピングが起きる現象
    * ストレージへのアクセスはメモリのそれと比べて格段に遅い

## swapon --show
* スワップ領域を確認するコマンド
* サイズだけなら`free`でも確認可能
* 定期的に確認するなら`sar -W <秒>`でもいい

## フラット型ページテーブル
* 一次元配列的なページテーブル

## 階層型ページテーブル
* 多次元配列的なページテーブル
* フラット型に比べ、ページテーブルエントリ数が減る
* ページテーブルに使用している物理メモリ量は、`sar -r ALL`の`kbpgtbl`フィールドで確認できる

# 6章

## 記憶装置

* 上の方ほどサイズが小さく、高価で、アクセス速度が速い

|:--|
|レジスタ|
|キャッシュメモリ|
|メモリ|
|ストレージデバイス|

## キャッシュメモリ
* アクセスの速いレジスタと遅いメモリの間を介在する
* キャッシュメモリがいっぱいになった状態でキャッシュ内に存在しないデータを読み書きすると、既存のキャッシュラインのうち1つを廃棄
* 最近のx86_64アーキテクチャのCPUでは、キャッシュメモリは階層型構造となっている
    * L1, L2, L3など番号の若い順にCPUに近く、容量が少なく、高速
* キャッシュメモリの情報は、`/sys/devices/system/cpu/cpu<%d>/cache/index<%d>/`のファイルに記載

## 参照の局所性
* 時間的局所性
    * ある時点でアクセスされたデータは、再びアクセスされる可能性が高い
        * ex. ループ処理
* 空間的局所性
    * ある時点でアクセスされたデータの近くにあるデータはアクセスされる可能性が高い
        * ex. 配列
* プログラムの実行速度を重視するなら、キャッシュメモリに収まる程度のデータ構造やアルゴリズムを検討する必要がある

## TLB
* Translation Lookside Buffer
* 仮想アドレス・物理アドレスの変換表を保持する領域
* CPU上にある
* キャッシュメモリと同程度に高速
* 物理メモリ上にあるページテーブルへアクセスすることなく、仮想アドレスを物理アドレスに変換できる

## ページキャッシュ
* ストレージ上のファイルデータをページ単位でメモリにキャッシュする
    1. プロセスがファイルのデータを読み出そうとする
    2. カーネルは一旦カーネルメモリ上にあるページキャッシュにコピーしてから、そのデータをプロセスメモリにコピー
    3. 同じデータの読み出しに対しては、ページキャッシュ上のデータを返す 
    4. プロセスがデータをファイルに書き込むと、カーネルはページキャッシュだけにデータを書き込む
    5. 上書きされたデータ(ダーティページ)は、カーネルのバックグラウンド処理によってストレージ上のファイルに反映
* ストレージ上のファイルを直接弄くらないので、高速

## ハイパースレッド機能
* CPUのレジスタなどの一部の資源を複数用意し、それぞれシステムからは論理CPUとして認識されるものに分割する機能
* これによってスループットが向上するかは状況次第
* プロセスに対するスレッドとは意味が違うし関係ない